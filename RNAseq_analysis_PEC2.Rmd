---
title: "Análisis de datos de expresión (RNA-seq) en muestras de infiltración de tiroides"
subtitle: "Análisis Datos Ómicos - PEC 2"
author: "Jorge Vallejo Ortega"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    toc: true
  pdf_document:
    number_sections: true
    toc: true
header-includes:
  - \renewcommand{\contentsname}{Índice}
  
# Next code for knitting both types of documents automatically comes from https://stackoverflow.com/questions/39662365/knit-one-markdown-file-to-two-output-files/53280491#53280491
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_format = "all",
  output_dir = "results") })
# And:
# https://stackoverflow.com/a/46007686/10647267

bibliography: references.bib
---

```{r setup, include=FALSE}
# knitr options

# Do not display code in output document
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.align = "center")
```

```{r estructura de directorios, results='hide'}
# 'data' contains raw source data.
# 'intermediateData' contains .RData objects with processed data.
# 'results' stores the final report files.

directories <- c("data", "results", "intermediateData", "images")

# Create directories
lapply(directories, function(x){
         if (!(dir.exists(x))){
           dir.create(x)
         }
       })
```

```{r delete results files, eval= FALSE}
# Run this chunk ONLY if you want to re-do
# the complete the report FROM THE ORIGINAL DATA.
# Remember that the .RData files are there to
# avoid unnecesarily redoing of long data processing.

directories <- c("results/", "intermediateData/", "images/")

file.remove(
  # Create a character vector of relative paths
  # to all files in the variable directories
  list.files(path = directories,
           all.files = TRUE,
           full.names = TRUE,
           recursive = TRUE)
)
```

```{r libraries, include=FALSE}
# Load packages
library(knitr)

```



\newpage
# Abstract
**Análisis de expresión génica diferencial** de un estudio obtenido del proyecto [Genotype-Tissue Expression (GTEx)](https://gtexportal.org/home/). Partimos de datos de expresión obtenidos por **RNA-seq**, pertenecientes a un análisis de muestras tiroides pertenecientes a tres grupos: NIT (_not infiltrated tissues_, tejidos no infiltrados), SFI (_small focal infiltrates_, infiltrados focales pequeños), y ELI (_extensive lymphoid infiltrates_, infiltrados linfoides amplios). Como resultado hemos obtenido **listados de genes** con expresión diferencial entre los diferentes grupos, y **listados de términos GO** sobrerrepresentados en dichos listados.

# Objetivos
Los objetivos de este análisis son  
i) averiguar los cambios de expresión génica en la tiroides entre situación de salud (NIT) y situación patológica (SFI y ELI),  
ii) explorar los cambios en la expresión génica entre tejidos de tiroides en situación patológica más severa (ELI) y menos severa (SFI), y finalmente  
iii) examinar las rutas moleculares implicadas.

# Materiales y métodos

## Datos de origen
Originalmente, los datos brutos fueron obtenidos por RNA-seq y proceden del proyecto [Genotype-Tissue Expression (GTEx)](https://gtexportal.org/home/). Para este análisis, sin embargo, he trabajado con datos ya pre-procesados en forma de dos archivos con formato CSV. Estos archivos (counts.csv y targets.csv) se pueden encontrar en mi perfil de GitHub siguiendo XXXXeste enlaceXXXX.

El archivo counts.csv contiene el número de cuentas detectadas para cada gen en cada muestra del estudio. Es una tabla en la que cada observación (fila) corresponde a un gen reconocido por el proyecto Ensembl, y cada variable (columna) a una de las muestras de tejido del estudio. A partir de los datos de este archivo podemos analizar la expresión de cada gen en cada muestra.

El archivo targets.csv contiene información relevante acerca de cada muestra. Cada observación (fila) de la tabla corresponde a una muestra, y cada variable (columna) corresponde a una característica de la muestra como el código de identificación, el tejido de origen, el grupo experimental al que pertenece, o el sexo del sujeto del que procede la muestra.

## Diseño experimental

El total de muestras es de 292; divididas en 236 muestras del grupo NIT, 42 muestras del grupo SFI y 14 muestras del grupo ELI. Para este informe se nos pidió seleccionar 10 muestras, aleatoriamente, de cada grupo para trabajar sobre un total de 30 muestras.

Debido a que los perfiles de expresión génica pueden variar según el sexo [@naqvi2019conservation], he seleccionado las muestras de tal forma que, dentro de cada grupo experimental, la cantidad de muestras provenientes de hembras sea la misma que de varones (ver sección ["Obtención de los datos en bruto"](#obtencion)).

Como hay tres grupos, el análisis de expresión diferencial lo he efectuado sobre tres comparaciones: SFI-NIT, ELI-NIT y ELI-SFI.

## Procedimiento seguido en el análisis

Los pasos seguidos para realizar el presente análisis han sido los siguientes: 

1. Obtención de los datos de expresión en bruto.  
2. Control de calidad de los datos.  
3. Normalización.  
4. Filtraje no específico.  
5. Identificación de genes diferencialmente expresados.  
6. Anotación de los resultados.  
7. Comparación entre comparaciones.  
8. Análisis del enriquecimiento de rutas.

<a name="obtencion"></a>  

### Obtención de los datos en bruto

Como se ha señalado anteriormente, hemos recibido dos archivos con formato CSV conteniendo los datos pre-procesados de 292 muestras, de las cuales debíamos seleccionar al azar 10 de cada grupo experimental (en total 30 muestras).

Para seleccionar las muestras al azar, he dividido primero el total de muestras por grupos experimentales (NIT, SFI y ELI), y cada grupo lo he dividido por sexos (varón y hembra). De cada uno de esos grupos (NIT-varones, NIT-hembras, SFI-varones, etc.) he elegido al azar 5 muestras para un total de 30 muestras sobre las que realizar el informe.
```{r samples table}
groups <- c("NIT", "SFI", "ELI")

knitr::kable(as.data.frame(matrix(rep(5, times=6), nrow = 3, ncol = 2),
                     row.names = groups),
col.names= c("varones", "hembras"),
align = 'c', caption = "Distribución de la cantidad de muestras en este informe.")

```

Todo el trabajo de selección y procesado de datos, y los análisis estadísticos, han sido realizados con el lenguaje de programación R. El entorno de desarrollo ha sido RStudio. Muchos de los paquetes usados como extensión de R han sido obtenidos de Bioconductor, con especial relevancia para este informe del paquete DESeq2. El listado completo de los paquetes usados y sus versiones se puede leer en el [apéndice B](#apendiceB). El código utilizado para la manipulación de datos, y la composición de este informe, así como los archivos con los datos; puede consultarse en mi página de Github: [https://github.com/jorgevallejo/RNAseq_analysis_PEC2](https://github.com/jorgevallejo/RNAseq_analysis_PEC2)

```{r read data into R}
# Read targets
targets <- read.csv("data/targets.csv", stringsAsFactors = FALSE)
# Read counts
if (file.exists("intermediateData/counts.RData")){
  load("intermediateData/counts.RData")
}else{
  counts <- read.csv2("data/counts.csv", stringsAsFactors = FALSE)
  save(counts, file="intermediateData/counts.RData")
}
```

```{r explore data, eval=FALSE}
# Check loaded data and its structure
head(targets)
str(targets)

counts[1:6,1:6]
str(counts)
```
<!-- **Targets** -->
<!-- Cada observación es una muestra. -->
<!-- Variables: "Experiment", "SRA_Sample", "Sample_Name", "Grupo_analisis", "body_site", "molecular_data_type", "sex"  -->

<!-- **Counts** -->
<!-- Cada observación es un ¿gen? -->
<!-- La primera variable es el código del gen? -->
<!-- Cada variable es una muestra. -->

```{r take samples from each group stratified by sex}
# Check if there are duplicates of Sample_Name
# sum(duplicated(targest$Sample_Name))

# Take 10 samples from each group at random
set.seed(50110528)


# Function for the stratified sampling
sampler <- function (targets, groups){
  targets_sampled <- NULL
  for (group in groups){
    targets_male <- targets[targets$Group == group &
                            targets$sex == "male", ]
    targets_female <- targets[targets$Group == group &
                            targets$sex == "female", ]
    targets_sampled <- rbind(targets_sampled,
                       targets_male[sample(nrow(targets_male), 5), ],
                       targets_female[sample(nrow(targets_female), 5), ])
}
  return (targets_sampled)
}

# Take the sample
targets_sampled <- sampler(targets, groups)
```

```{r subset counts data frame}
# Transform experiments name format
sample_names <- targets_sampled$Sample_Name
sample_names <- gsub("-", ".", sample_names)
# Add back gene column
sample_names <- c("X", sample_names)

#Subset counts data frame with sample names
counts_subset <- counts[, names(counts) %in% sample_names]
# Make variable X into rownames
rownames(counts_subset) <- counts_subset$X
counts_subset <- counts_subset[-1]

# Change colnames from sample name to short name
## Subset to columns Sample_Name and ShortName
targets_shortname <- targets[, c(3, 9)]
## Change Sample_Name format
targets_shortname$Sample_Name <- gsub("-", ".", targets_shortname$Sample_Name)
## Merge
longnames <- data.frame(colnames(counts_subset))
shortnames <- merge(longnames,
                    targets_shortname,
                    by.x = colnames(longnames),
                    by.y="Sample_Name")
# Change counts_subset colnames for shortnames
colnames(counts_subset) <- shortnames$ShortName
```

```{r order counts_subset rows by Group and sample name}
# This is necessary for the samples to appear ordered by experimental
# group in the box plot

counts_subset <- counts_subset[, order(
  substr(colnames(counts_subset), 7, 9),
  colnames(counts_subset))]

# Put targets rows in the same order than counts columns
# This is necessary for creating the DESeqDataSet object
targets_sampled <- targets_sampled[order(targets_sampled$Group,
                                         targets_sampled$ShortName), ]
```

### Control de calidad de los datos
Con el control de calidad pretendemos averiguar si los datos de alguna de las muestras presentan defectos o sesgos que desaconsejen usarlos, antes de continuar con el análisis.

En este caso hemos usado examinado los datos de expresión mediante diferenes representaciones gráficas, en busca de anomalías.

#### Distribución de los datos en bruto y normalización

```{r histogram raw counts}
library(ggplot2)
library(gridExtra)

interfile <- "images/histo_pseudo.png"

if (!(file.exists(interfile))){
histo_counts <- ggplot(counts_subset,
       aes(x = counts_subset[, 1])) +
  geom_histogram(fill = "#525252", binwidth = 2000) + 
  labs(x = "Cuentas", y = "Frecuencia",
       title = paste0("Muestra ", names(counts_subset)[1])) +
  scale_y_log10() + 
  coord_cartesian(xlim = c(0, 300000))
}
```

Como la distribución de las cuentas presenta una alta asimetría, hemos transformado los datos de cuentas en pseudocuentas (log~2~(cuentas + 1)) para aproximar la distribución a la curva normal. Esta transformación ayudará a la visualización de los datos.

```{r transform count data to log2}
pseudoCounts <- log2(counts_subset + 1)
```

```{r histogram of pseudocounts}

if (!(file.exists(interfile))){
histo_pseudocounts <- ggplot(pseudoCounts,
       aes(x = pseudoCounts[, 1])) +
  geom_histogram(colour = "white", fill = "#525252", binwidth = 0.5) + 
  labs(x = "Pseudocuentas", y = "Frecuencia",
       title = paste0("Muestra ", names(counts_subset)[1]))
}
```

```{r print histocounts and histopseudocounts, out.width='75%', fig.cap='(izq.) Las cuentas de los genes en la muestra presentan una distribución fuertemente asimétrica hacia números bajos. La transformación en pseudocuentas (der.) produce un perfil de frecuencias más parecido a la distribución normal.'}

interfile <- "images/histo_pseudo.png"

#save grid of graphs
if(file.exists(interfile)){
  knitr::include_graphics(interfile) # Draw image
}else{
histo_pseudo <- arrangeGrob(histo_counts, histo_pseudocounts, ncol = 2) # Generate grid
ggsave(filename = interfile, histo_pseudo) # Save image
knitr::include_graphics(interfile) # Draw image
}

# Remove big objects from environment
rm(list = c("histo_counts", "histo_pseudocounts"))
```
\newpage

#### Distribución de pseudocuentas por muestra (diagramas de cajas)
Con los diagramas de cajas podemos observar y comparar la distribución de las pseudocuentas en las diferentes muestras. Esto comprobar si alguna de las muestras presenta una distribución radicalmente distinta del resto, lo que sería señal de algún error o problema con esa muestra:

```{r boxplots, out.width='75%', fig.cap='Diagramas de cajas construidos a partir de las pseudocuentas de los datos. Cada color representa un grupo experimental. La distribución de datos es similar en todas las muestras.'}
library('reshape')

# Melt pseudocounts
interfile <- "intermediateData/pseudoCounts_melted.RData"

if(file.exists(interfile)){
  load(interfile)
}else{
  pseudoCounts_melted <- melt(pseudoCounts, variable_name = "Muestras")
  save(pseudoCounts_melted, file = interfile)
}

# Add experimental group to melted dataframe
pseudoCounts_melted <- data.frame(pseudoCounts_melted, 
                                  Grupo = substr(pseudoCounts_melted$Muestras, 7, 9))

# Draw boxplot of pseudocounts distribution
interfile <- "images/pseudoCounts_boxplots.png"

if(file.exists(interfile)){
  knitr::include_graphics(interfile)
}else{
 boxplots <- ggplot(pseudoCounts_melted, aes(x = Muestras, y = value, fill = Grupo)) +
  geom_boxplot() +
  xlab("Muestras") +
  ylab(expression(log[2](count + 1))) +
  scale_fill_manual(values = c("red", "blue", "green")) +
  scale_x_discrete(limits = targets_sampled$ShortName) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = rel(0.8)))

 ggsave(filename = interfile)
 knitr::include_graphics(interfile)
}
```
\newpage

#### Distribución de pseudocuentas por muestra (histogramas de densidad)

Los histogramas nos ofrecen una perspectiva diferente sobre la distribución de las pseudocuentas, más detallada que los diagramas de cajas.

```{r histograms and density plots, out.width='75%', fig.cap='Histogramas suavizados de densidades de pseudocuentas en cada muestra, separados por grupo experimental.'}

interfile <- "images/histo_density.png"

if(file.exists(interfile)){
  knitr::include_graphics(interfile)
}else{
  # Generate histograms
ggplot(pseudoCounts_melted, aes(x = value, colour = Muestras, fill = Muestras)) +
  ylim(c(0, 0.25)) +
  geom_density(alpha = 0.2, size = 0.25) +
  facet_wrap(~ Grupo, dir = 'v') +
  theme(legend.position = "none") +
  xlab(expression(log[2](count + 1)))
  #theme(aspect.ratio = 1) # makes the different graphs into squares
  # Save
  ggsave(filename = interfile)
  # Draw in document
  knitr::include_graphics(interfile)
}
```

En general, el perfil de los histogramas es muy parecido para todas las muestras y entre los diferentes grupos experimentales.
\newpage

#### Mapa de calor
Los mapas de calor ayudan a explorar los parecidos y diferencias entre muestras. Mediante colores que representan las distancias entre muestras, y agrupando jerárquicamente muestras según su similaridad.

```{r heatmap of sample-to-sample distance, out.width='75%'}
mat.dist <- as.matrix(dist(t(pseudoCounts)))
mat.dist <- mat.dist/max(mat.dist)

library('RColorBrewer')
hmcol <- colorRampPalette(brewer.pal(9, "GnBu"))(255)

```
```{r heatmap 2, fig.cap='Mapa de calor de la distancia relativa entre muestras. El dendrograma en la parte superior agrupa las muestras jerárquicamente por proximidad.'}
library(gplots)

heatmap.2(mat.dist,
          Rowv = TRUE,
          Colv = TRUE,
          dendrogram = "column",
          main = "",
          scale = "none",
          col = rev(hmcol),
          sepcolor = "white",
          sepwidth = c(0.05, 0.05),
          cexRow = 0.5,
          cexCol = 0.5,
          key = TRUE,
          keysize = 1.5,
          density.info = "none",
          tracecol = NULL,
          srtCol = 30,
          ColSideColors = c(
            rep("red", 10), # ELI
             rep("green", 10), # NIT
             rep("blue", 10) # SFI
             ),
          colsep = c(4),
          key.title = NA,
          key.xlab = 'Distancia relativa'
          )

# Legend
legend("left", # Position of the legend in the graph
       legend = c("ELI", "NIT", "SFI"),
       fill = c("red", "green", "blue"), # Colors of the boxes
       border = NA, # Do not draw a box around the colors
       bty = 'n', # Do not draw a box around the legend
       cex = 0.75) # Size of the characters
```

Por lo que podemos ver en el mapa de calor, la mayor parte de las muestras del grupo ELI (infiltraciones amplias) se agrupan entre ellas (aunque en dos grupos diferentes), mientras que el resto de agrupaciones son mezclas de muestras de los grupos SFI (infiltraciones pequeñas) y NIT (sin infiltraciones).
\newpage

#### Análisis de componentes principales de las muestras

Éste tipo de gráfica se puede usar para reconocer las características clave en sets de datos multidimensionales. Esto es, aquellas características que explican la mayor parte de la variabilidad en los datos.

Al aplicar el análisis sobre nuestros datos, esperamos que las muestras se agrupen por grupo experimental y, probablemente, por sexo.

```{r plot PCA, out.width='50%', fig.cap='Análisis de componentes principales. PC1: Fuente principal de variabilidad entre muestras. Parece corresponder al grupo experimental. PC2: Segunda mayor fuente de variabilidad entre muestras. Separa claramente las muestras de hembras y varones.'}
library('DESeq2')
library('Biobase')

# Link ordered shortnames with experimental group
targets_sampled_ordered <- targets_sampled[order(targets_sampled$Group,
                        targets_sampled$ShortName), ]

annot <- AnnotatedDataFrame(
  data = data.frame(Group = targets_sampled_ordered$Group,
                    sex = targets_sampled_ordered$sex,
                    row.names=colnames(pseudoCounts)))

expSet <- new("ExpressionSet",
              exprs = as.matrix(pseudoCounts),
              phenoData = annot)

DESeq::plotPCA(expSet, intgroup =c("Group", "sex"))
```

En el resultado de la gráfica vemos que la separación entre grupos no es clara. Las muestras del grupo ELI en su mayoría se reúnen a la izquierda del gráfico, las muestras NIT a la derecha, y las muestras SFI se entremezclan con ambos grupos definiendo una posición más o menos central. La separación entre sexos sin embargo, es clara, con las muestras procedentes de varones en la zona superior y las de hembras en la inferior.


### Filtraje no específico

Una primera medida para disminuir el ruido estadístico, y agilizar la velocidad de los cálculos, consiste en eliminar todos aquellos genes con ninguna o muy poca expresión. Podemos eliminarlos con relativa seguridad porque, si no se expresan en las muestras de ninguno de los dos grupos, tampoco nos están ofreciendo ninguna información respecto a expresión diferencial.

Eliminamos del dataset aquellos genes con menos de dos cuentas en total (teniendo en cuenta todas las muestras).

```{r Total de genes en el dataset}
genes_total <- nrow(counts_subset)
```

```{r Genes pre-filtrados}
counts_subset <- counts_subset[rowSums(counts_subset) > 1, ]
genes_postfilter <- nrow(counts_subset)
```
Total inicial de genes en el set de datos: `r format(genes_total, big.mark = " ")` genes.  
Total genes después de filtrar: `r format(genes_postfilter, big.mark = " ")` genes.  
Genes filtrados:`r  format(genes_total - genes_postfilter, big.mark = " ")`

```{r remove unnecesary varibles from environment}
rm(list = c("genes_total", "genes_postfilter"))
```
\newpage

### Transformación de los datos: normalización

```{r construct DESeqDataSet object, eval}
# After pre-filterning and before normalization and stabilizing variance
# it is time to generate the DESeqDataSet object
library('DESeq2')
ddsMat <- DESeqDataSetFromMatrix(countData = counts_subset,
                                 colData = targets_sampled,
                                 # Group is last because in the studied factor
                                 design =  ~ sex + Group)
```
Las estrategias de normalización sirven para disminuir diferencias entre muestras provocadas por sesgos técnicos. Uno de los sesgos más comunes en RNA-seq son las diferencias en el número de lecturas en cada muestra, y para corregirlo hemos elegido el método conocido como _expressión de logaritmo relativo_ (RLE por sus siglas en inglés).

```{r estimate normalization factors}

if (file.exists("intermediateData/ddsMat_sizeFactors.RData")){
  load("intermediateData/ddsMat_sizeFactors.RData")
}else{
  ddsMat <- estimateSizeFactors(ddsMat)
  save(ddsMat, file = "intermediateData/ddsMat_sizeFactors.RData")
}
```

```{r inspect size factors}
kable(as.data.frame(cbind(Muestras = names(sizeFactors(ddsMat)),
                    Factores = round(sizeFactors(ddsMat), digits = 4))),
      row.names = FALSE,
      caption = 'Factores de normalización aplicados a cada muestra (redondeados a 4 dígitos).',
      align = 'rl')
```

Obsérvese que ninguno de los factores se aleja excesivamente de la unidad, lo que apunta a que ninguna de las muestras estudiadas tiene una profundidad de lectura muy alejada del resto.
\newpage

### Transformación de los datos: estabilización de la varianza

Por lo general, el análisis de datos multidimensional es muy sensible a cambios en la varianza. Por eso hemos transformado los datos para que la medias de cuentas de los diferentes genes presenten aproximadamente la misma varianza.

Debido a que el tamaño del dataset empieza a entrar en un rango mediano (30 muestras), hemos utilizado el método de transformación estabilizadora de la varianza (VST).

```{r transformación estabilizadora de la varianza}
if(file.exists("intermediateData/vsd.RData")){
  load("intermediateData/vsd.RData")
}else{
  vsd <- vst(ddsMat, blind = FALSE)
  save(vsd, file = "intermediateData/vsd.RData")
}

# assay(vsd)[1:3, 1:3] # check assay data
```

```{r check colData, eval=FALSE}
colData(vsd)
```

```{r check effect of transformation}
library('dplyr')

df <- bind_rows(
  as_data_frame(log2(counts(ddsMat, normalized = TRUE)[, 1:2]+1)) %>%
    mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst")
)
```
```{r variabilidad expresion en dos muestras, out.width='50%', fig.cap='La mayor variabilidad en la expresión génica se encuentra en aquellos genes con menos cuentas. La transformación estabilizadora de varianza (VST) elimina dicha variabilidad.'}
library('ggplot2')

interfile <- "images/variabilidad.png"

if(file.exists(interfile)){
  knitr::include_graphics(interfile)
}else{
colnames(df)[1:2] <- c("muestra_1", "muestra_2")
# Generate plot
variabilidad <- ggplot(df, aes(x= muestra_1, y = muestra_2)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid(. ~ transformation)
# Save plot
ggsave(interfile, variabilidad)
# Draw plot
knitr::include_graphics(interfile)
}
```
\newpage

### Distancia entre muestras

Con los datos transformados (normalización y estabilización de varianza), volvemos a examinar gráficamente la relación entre muestras.


#### Mapa de calor

Mediante un mapa de calor podemos qué muestras se parecen más entre ellas. Esperamos que muestras del mismo grupo experimental se agrupen entre sí.

```{r heatmap of sample-to-sample distance with transformed data}
# Calculate distance matrix
mat.dist <- as.matrix(dist(t(assay(vsd))))
# Make distances relative
mat.dist <- mat.dist/max(mat.dist)
# Color palette for distances
library('RColorBrewer')
hmcol <- colorRampPalette(brewer.pal(9, "GnBu"))(255)
```
```{r draw heatmap transformed data, out.width='75%', fig.cap='Mapa de calor de la distancia relativa entre muestras, a partir de datos transformados. El dendrograma en la parte superior agrupa las muestras jerárquicamente por proximidad.'}

heatmap.2(mat.dist,
          Rowv = TRUE,
          Colv = TRUE,
          dendrogram = "column",
          main = "",
          scale = "none",
          col = rev(hmcol),
          sepcolor = "white",
          sepwidth = c(0.05, 0.05),
          cexRow = 0.5,
          cexCol = 0.5,
          key = TRUE,
          keysize = 1.5,
          density.info = "none",
          tracecol = NULL,
          srtCol = 30,
          ColSideColors = c(
            rep("red", 10), # ELI
             rep("green", 10), # NIT
             rep("blue", 10) # SFI
             ),
          colsep = c(2, 11), # Columns after which introduce breaks
          key.title = NA,
          key.xlab = 'Distancia relativa'
          )

# Legend
legend("left", # Position of the legend in the graph
       legend = c("ELI", "NIT", "SFI"),
       fill = c("red", "green", "blue"), # Colors of the boxes
       border = NA, # Do not draw a box around the colors
       bty = 'n', # Do not draw a box around the legend
       cex = 0.75) # Size of the characters
```

En este nuevo mapa de calor de distancia entre muestras, con datos ya transformados mediante normalización y estabilización de la varianza, vemos un panorama similar el del mapa anterior.
La mayor parte de las muestras del grupo ELI (infiltraciones amplias) se reúnen en dos grupos diferentes, mientras que el resto de agrupaciones son mezclas de muestras de los grupos SFI (infiltraciones pequeñas) y NIT (sin infiltraciones).

### Análisis de componentes principales

```{r PCA plot con datos VST, out.width='50%', fig.cap='Gráfica de análisis de componentes principales. Cada marca representa una muestra, codificada según el grupo experimental al que pertence (color) y el sexo (forma).'}
# DESeq2::plotPCA(vsd, intgroup = c("Group", "sex"))
pcaData <- plotPCA(vsd, intgroup=c("Group", "sex"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Group, shape=sex)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% varianza")) +
  ylab(paste0("PC2: ",percentVar[2],"% varianza")) + 
  coord_fixed()
```

Al igual que observamos con los datos sin transformar, la mayor parte de la varianza parece deberse al grupo experimental, con las muestras del grupo ELI en su mayoría reúnidas a la izquierda del gráfico, las muestras NIT a la derecha, y las muestras SFI entremezcladas con ambos grupos formando una suerte de puente. La aportación a la varianza por sexos sigue siendo clara, con las muestras procedentes de varones en la zona superior y las de hembras en la inferior.

### Identificación de genes diferencialmente expresados

Después de explorar los datos para comprender su estructura, realizar análisis de calidad, normalizar los datos de expresión, estabilizar la varianza, y filtrar los genes menos informativos; llega el momento de analizar qué genes se expresan de forma diferente entre los diferentes grupos experimentales.

Para el análisis de este ensayo, consideramos una matriz de diseño siguiendo un modelo lineal de dos factores ( _grupo experimental_ y _sexo_ ). El factor _sexo_ con dos niveles: _varón_ y _hembra_. El factor _grupo experimental_, con tres niveles ( _NIT_, _SFI_ y _ELI_ ), se ha considerado como factor principal.

Así, la fórmula para el modelo lineal toma la forma: $cuentas = sexo + \textit{grupo experimental}$

El análisis estadístico se ha llevado a cabo mediante la función `DESeq()` del paquete _DESeq2_ de Bioconductor, que realiza una estimación de los factores de tamaño, estimación de la dispersión, y ajuste al modelo lineal generalizado (GLM) usando la distribución binomial negativa.

```{r differential expression analysis}
# Remove large unnecesary objects from environment
rm(list=c("vsd", "expSet"))

# Differential expression analysis parallelized
if(file.exists("intermediateData/ddsMat_dea.RData")){
  load("intermediateData/ddsMat_dea.RData")
}else{
  ddsMat <- DESeq(ddsMat, parallel = TRUE)
  save(ddsMat, file="intermediateData/ddsMat_dea.RData")
}
```

Como resultado del análisis estadístico obtenemos, para cada comparación entre grupos, los cambios relativos de expresión en cada gen (log2 fold change) y el p-valor ajustado que nos informa acerca de la significatividad de ese cambio.

```{r leg2 fold changes}
interfile <- "intermediateData/leg2_fold_changes.RData"

if(file.exists(interfile)){
  load(interfile)
}else{
# SFI-NIT
res_SFIvsNIT <- results(ddsMat, 
               contrast = c("Group", "SFI", "NIT")) # SFI is numerator in fold change

# ELI-NIT
res_ELIvsNIT <- results(ddsMat, 
               contrast = c("Group", "ELI", "NIT")) # ELI is numerator in fold change

# ELI-SFI
res_ELIvsSFI <- results(ddsMat, 
               contrast = c("Group", "ELI", "SFI")) # ELI is numerator in fold change

save(list = c("res_SFIvsNIT", "res_ELIvsNIT", "res_ELIvsSFI"),
     file = interfile)
}


# res_NITvSFI
```

```{r meaning of the columns, eval=FALSE}
mcols(res_SFIvsNIT, use.names = TRUE)
```

```{r summarize the results, eval=FALSE}
summary(res_SFIvsNIT)
```

Como ejemplo, mostramos aquí los seis genes con menor p-valor ajustado de la comparación SFI-NIT:

```{r example table of differentially expressed genes}
# Order by adjusted p-value
res_SFIvsNIT_trimmed <- res_SFIvsNIT[!is.na(res_SFIvsNIT$padj) & # Takes care of NA values
                                     res_SFIvsNIT$padj < 0.1 # FDR < 10%
                                     , c(2, 6)] # Columns log2FC and p.adusted

knitr::kable(head(res_SFIvsNIT_trimmed[order(res_SFIvsNIT_trimmed$padj), ]),
             col.names = c("log2FC", "p-valor ajustado"),
             align = 'cc',
             digits = c(2, 4),
             caption = 'Ejemplo de genes con expresión diferencial entre los grupos SFI y NIT, ordenados por menor p-valor ajustado. Incluye el valor log2FC y el código ENSEMBL del gen. FDR < 10%.')
```


```{r display log fold changes versus expression strength, fig.cap='Gráfica mostrando expresion diferencial (log-fold changes) frente a fuerza de expresion (media de cuentas normalizadas). Los puntos rojos representan los genes con un p-valor ajustado inferior a 0.1'}
plotMA(res_NITvSFI)
```

Si consideramos aceptable una fracción de falsos positivos del 10%, podemos considerar como significativos todos aquellos genes con un p-valor ajustado por debajo de 0.1:
```{r genes con p valor ajustado menor de 0.1}
sum(res_NITvSFI$padj < 0.1, na.rm=TRUE)
```

De la tabla de resultados, seleccionamos sólo esos genes y los ordenamos por la estimación del log2 fold change para recoger los genes más significativos con la regulación negativa más acusada:

```{r strongest down-regulation}
resSig <- subset(res_NITvSFI, padj < 0.1)
head(resSig[order(resSig$log2FoldChange), ])
```

Genes más significativos con la regulación positiva más acusada:
```{r strongest up-regulation}
head(resSig[order(resSig$log2FoldChange, decreasing = TRUE), ])
```

```{r store NITvsSFI results in csv file}
if (!(file.exists("results/res_NITvsSFI.csv"))){
  write.csv(res, file = "results/res_NITvsSFI.csv")
}
```

La lista completa de genes con expresión diferencial entre los grupos NIT y SFI puede descargarse como un archivo en formato CSV XXXXdesde este enlaceXXXX.

## Gráficas de resultados


### Histograma de p-valores no ajustados

```{r histogram of unadjusted p values, fig.cap="Histograma de p-valores no ajustados de cada gen. El perfil esperado es el de un pico de genes cercanos al valor 0, y el resto de genes repartidos en el abanico de probabilidades."}
hist(res_NITvSFI$pvalue[res_NITvSFI$baseMean > 1], breaks = 100,
     col = "grey50", border = "white",
     main = "", xlab = "P valores no ajustados", ylab = "Frecuencia")
```

### Agrupación jerárquica de los genes más variables

```{r separar los genes mas variables}
library('genefilter')
load("intermediateData/vsd.RData")
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)
```

```{r draw a heatmap, fig.cap= 'Mapa de calor de los 20 genes con mayor variación entre muestras. Cada columna representa una muestra, y cada fila representa uno de los genes.'}
library(pheatmap)
mat <- assay(vsd)[topVarGenes, ]
# Calculate the amount by which each gene deviates in a specific sample
# from the gene average across the samples
mat <- mat - rowMeans(mat)
anno <- data.frame(Grupo = colData(vsd)[, c("Group")])
rownames(anno) <- colnames(mat)
pheatmap(mat, annotation_col = anno,
         angle_col = 45)

```

Vemos que las muestras se reúnen en dos grandes grupos; uno de ellos el grupo control (NIT), el otro todas las muestras infiltradas (SFI y ELI) sin que haya una diferencia clara entre ambos grupos de infiltradas.

Lo genes representados en el mapa de calor, aquellos 20 que presentan mayor varianción intermuestral, parecen dividirse en dos grandes grupos.

### Anotación de las listas de genes

En las listas que hemos generado los genes están identificados por un código Ensembl. Sin embargo, a nosotros humanos nos resulta más cómodo trabajar con los símbolos o nombres de cada gen. Es por eso que hemos procedido a anotar las listas para incluir el símbolo de cada gen y su código Entrez.

No debemos de dejar de tener en cuenta, sin embargo, que las bases de datos Ensembl y Entrez utilizan criterios diferentes para definir qué es un gen, y tienen requisitos diferentes para incluir un gen en la base de datos. Esto tiene como consecuencia que muchos de los códigos de Ensembl no tengan su equivalente en códigos Entrez. Estos últimos, sin embargo, serán necesarios para el análisis de significación biológica. Así pues, como parte del análisis de expresión diferencial hemos producido dos listas; una con los códigos Ensembl, y otra con los códigos Entrez que no coincide exactamente con la primera.

```{r load annotation libraries}
library('AnnotationDbi')
library('org.Hs.eg.db')
```

```{r annotate res object}
# Cut the version from the ensembl code
# From https://www.biostars.org/p/178726/
ensembl_codes <- gsub("\\..*", "", row.names(res_NITvSFI))

# Add symbol column
res_NITvSFI$symbol <- mapIds(org.Hs.eg.db,
                     keys = ensembl_codes,
                     column = "SYMBOL",
                     keytype = "ENSEMBL",
                     multiVals = "first")

# Add Entrez ID
res_NITvSFI$entrez <- mapIds(org.Hs.eg.db,
                     keys = ensembl_codes,
                     column = "ENTREZID",
                     keytype = "ENSEMBL",
                     multiVals = "first")
```

Ejemplo del listado de genes, ordenado por p-valor ajustado (decreciente), incluyendo el símbolo del gen:

```{r genes with symbol ordered by p-value}
resOrdered <- res_NITvSFI[order(res_NITvSFI$padj),]

# Store as a csv
if(!(file.exists("results/resOrdered.csv"))){
  write.csv(resOrdered, file="results/resOrdered.csv")
}

head(resOrdered)
```

La lista completa de genes puede descargarse como archivo en formato CSV XXXXdesde este enlace.XXXX



### Comparaciones múltiples
Debido a que los grupos experimentales corresponden a grupo control (NIT), síntomas suaves (SFI), y síntomas severos (ELI); puede ser de gran interés saber qué genes presentan expresión diferencial, por ejemplo, en las comparaciones del grupo control frente a los grupos con síntomas,y qué genes presentan expresión diferencial sólo en las comparaciones entre grupos con síntomas pero no cuando se compara con el grupo control.

```{r decidetests, eval=FALSE}
# as many columns as comparisons and as many rows as genes.
res <- decideTests(fit.main, method="separate", adjust.method="fdr", p.value=0.1,
                   lfc = 0)
# This table can be annotated and saved as a csv file, for example
```

<!-- Podemos hacer primero una comparación cuantitativa entre las comparaciónes; cuántos genes diferenciales son exclusivos de una de las comparaciones y cuántos son comunes. -->

<!-- Resumen de los resultados: -->
```{r resumen comparaciones multiples, eval=FALSE}
sum.res.rows <- apply(abs(res), 1, sum)
res.selected <- res[sum.res.rows!=0, ]
print(summary(res))
```

#### Diagrama de Venn
```{r venn diagram, fig.height=4.5, fig.width=4.5, eval=FALSE}
vennDiagram(res.selected[, 1:2], cex=0.9)
title("Genes en común entre dos comparaciones\n Seleccionados con FDR <0.1",
      cex.main=0.9)
```

<!-- A partir del diagrama de Venn, vemos que **223** genes están diferencialmente poliadenilados sólo en las muestras "Control", y **627** sólo en las muestras "ASD". Son estos dos grupos de genes los que exploraremos para investigar las diferencias entre los grupos "Control" y "ASD". -->

<!-- Otro grupo de genes interesantes serían aquellos cuyo perfil de up/down regulación cambia en muestras de sujetos control y sujetos ASD. -->

<!-- Estos tres grupos son los que marcarán nuestra lista definitiva de genes de interés. -->

```{r lista definitiva interes, eval=FALSE}
# Solo nos interesan aquellos genes que:
## estan up o down regulados solo en uno de los grupos
## estan up en un grupo y down en el otro
dif.res.rows <- apply(res.selected, 1, function(x) {x[1] == x[2]})
res.selected2 <- res.selected[dif.res.rows == FALSE, ]
print(summary(res.selected2[, 1:2]))

```

```{r venn diagram lista interes, fig.height=4.5, fig.width=4.5, eval=FALSE}
vennDiagram(res.selected2[, 1:2], cex=0.9)
title("Genes en común entre dos comparaciones\n Seleccionados con FDR <0.1",
      cex.main=0.9)
```

<!-- En resumen, encontramos **223** genes exclusivamente en sujetos "Control2 cuyos ARNm tienen colas diferencialmente largas o cortas.   -->
<!-- Encontramos **627** genes exclusivamente en sujetos "ASD" cuyos ARNm tienen colas diferencialmente largas o cortas.   -->
<!-- **Ningún** gen con diferenciación invertida entre comparaciones. -->
```{r tablas listas genes exclusivos, eval=FALSE}
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.selected2), ],
           file = "results/common-differential-genes.csv", row.names = FALSE)
# Genes diferenciales exclusivos del grupo Control
res.control <- res.selected2[(res.selected2[,1] != 0) == TRUE, ]
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.control), ],
           file = "results/control-differential-genes.csv", row.names = FALSE)
# Genes diferenciales exclusivos del grupo ASD
res.ASD <- res.selected2[(res.selected2[,2] != 0) == TRUE, ]
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.ASD), ],
           file = "results/ASD-differential-genes.csv", row.names = FALSE)
```

### Significatividad biológica

Una vez tenemos nuestras listas de genes anotadas, un herramienta más para interpretar los resultados del estudio es el examen de la significatividad biológica. En este informe, lo que hemos hecho es, a partir de las listas de genes con comportamiento diferencial, comprobar si existen funciones, procesos biológicos o rutas moleculares que aparezcan con más frecuencia en estas listas que en el resto de genes analizados.

Como listas de genes hemos utilizado las siguientes:
**NITvsSFI** - lista de genes con comportamiento diferencial en la comparación entre los grupos NIT y SFI.
<!-- **Control** - lista de genes con comportamiento diferencial exclusivos del grupo "Control" (es un subset de la lista "Común"). -->
<!-- **ASD** - lista de genes con comportamiento diferencial exclusivos del grupo "ASD" (es un subset de la lista "Común"). -->

**Universo** - lista de todos los genes con código Entrez en la base de datos org.Hs.eg.db. XXXXreferenciaXXXX

```{r lista para significatividad biologica}

# Vector of EntrezIDs from the list of genes of interest, removing NAs
geneVector_NITvsSFI <- res_NITvSFI$entrez[!is.na(res_NITvSFI$entrez)]
# geneListControl <- as.character(read.csv2("results/control-differential-genes.csv")[, 4])
# geneListASD <- as.character(read.csv2("results/ASD-differential-genes.csv")[, 4])
geneVector_universe <- keys(org.Hs.eg.db, keytype = "ENTREZID")
```

#### Test de sobrerrepresentación de términos GO

El análisis estadístico lo hemos realizado con la función _enrichGO()_ del paquete _clusterProfiler_ para el lenguaje R. Esta función devuelve un listado de términos GO estadísticamente más representados en nuestra lista de genes, con respecto a la lista Universo.

```{r test de sobrerrepresentacion}
library(clusterProfiler)
library(org.Hs.eg.db)
# As universe, I will use all genes represented in the database
if(file.exists("intermediateData/ego.RData")){
  load("intermediateData/ego.RData")
}else{
ego <- enrichGO(gene = geneVector_NITvsSFI,
                universe = geneVector_universe,
                OrgDb = org.Hs.eg.db,
                ont = "CC",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.01,
                qvalueCutoff = 0.5,
                readable = TRUE)

 save(ego, file="intermediateData/ego.RData")
}
```

#### Gene Set Enrichment Analysis

Este tipo de análisis está especializado en detectar situaciones en las que las diferencias de expresión son pequeñas, pero coordinadas para un grupo de genes relacionados. En este informe hemos utilizado la función _gseGO_ del paquete _cluseterProfiler_ para realizar este análisis.
```{r Gene Set Enrichment Analysis, eval=FALSE}
# Generate ranked named vector of genes
gse_genelist <- res_NITvSFI[!is.na(res_NITvSFI$padj), ] # Remove NAs
gse_genelist <- gse_genelist[gse_genelist$padj < 0.1, ] # FDR 10%
gse_genelist <- setNames(abs(gse_genelist$log2FoldChange), # Named vector of fold changes
                         rownames(gse_genelist))
gse_genelist <- sort(gse_genelist, decreasing = TRUE) # Sort vector
names(gse_genelist) <- gsub("\\..*", "", names(gse_genelist)) # Truncate version number


egoset <- gseGO(geneList = gse_genelist,
              OrgDb = org.Hs.eg.db,
              ont = "ALL",
              keyType = "ENSEMBL",
              nPerm = 1000,
              minGSSize = 100,
              maxGSSize = 500,
              pvalueCutoff = 0.1,
              verbose = TRUE)
```

<!-- El resultado ha sido el mismo que en el análisis anterior. No se ha detectado ningún grupo de genes especialmente representado en el listado de nuestros genes de interés con ARN diferencialmente poliadenilados. -->

# Visualización de resultados
## Gráfico de barras
```{r enriquecimiento funcional barplot, fig.cap='Gráfico de barras para visualización de términos GO (componentes celulares) estadísticamente enriquecidos en la comparación NIT vs SFI. Se muestran los primeros veinte términos ordenados por p-valor ajustado en orden creciente.'}
library('enrichplot')

interfile <- "images/enri_barplot.png"

if(file.exists(interfile)){
  knitr::include_graphics(interfile)
}else{
  # Generate barplot
barplot(ego, showCategory = 20)
  # Save
  ggsave(filename = interfile)
  # Include in document
  knitr::include_graphics(interfile)
}
```

## Dot plot
```{r over-representation dot plot, fig.cap='Gráfico de puntos representado 30 términos GO (componentes celulares) significativos en análisis de sobre-representación para la comparación de los grupos NIT vs. SFI. Ordenados por tasa génica. El color de los puntos representa el p-valor ajustado del análisis; el tamaño representa la cantidad de genes.'}
dotplot(ego, showCategory = 30) + ggtitle('Dotplot the análisis de sobre-representación')
```

## Red conceptual
Con el gráfico de red conceptual representamos cómo un mismo gen puede pertenecer a varios términos.

```{r gene concept network, eval=FALSE}
# Lo dejo fuera del informa final porque en la gráfica me salen tal cantidad de genes
# que se vuelve ilegible.
# Convert gene ID to symbol
egox <- setReadable(ego, 'org.Hs.eg.db', keyType = 'auto')

cnetplot(egox, categorySize = 'pvalue')
```


# Discusión


# Apéndice A: Código

El documento original en formato .Rmd, que incluye el código completo en lenguaje R usado para generar este informe, se puede consultar y descargar en el siguiente repositorio de Github:
[]()

<a name="apendiceB"></a>

# Apéndice B: Reproducibilidad
```{r session_info, include=TRUE, echo=TRUE, results='markup'}
sessionInfo() # For better reproducibility
```


# Referencias